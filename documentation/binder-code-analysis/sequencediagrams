Sequence diagrams are generated by reading :
/sys/kernel/debug/binder/transaction_log

The logs look something like this :
30319178: reply from 437:579 to 959:980 node 0 handle -1 size 0:0
30319179: async from 959:980 to 437:0 node 2955 handle 6 size 80:0
30319180: async from 1339:1339 to 437:0 node 5854 handle 39 size 80:0
30319181: call  from 959:980 to 437:0 node 14 handle 1 size 1056:80
30319182: reply from 437:445 to 959:980 node 0 handle -1 size 0:0
30319183: async from 1339:1339 to 437:0 node 5854 handle 39 size 80:0
30319184: async from 1339:1339 to 437:0 node 5854 handle 39 size 80:0
30319185: async from 437:500 to 959:0 node 993 handle 2 size 68:0
30319189: async from 1339:1339 to 437:0 node 5854 handle 39 size 80:0
30319190: async from 1339:1339 to 437:0 node 5854 handle 39 size 80:0
30319191: async from 437:498 to 959:0 node 993 handle 2 size 68:0
30319192: async from 1859:1859 to 437:0 node 17327 handle 18 size 80:0
30319193: async from 437:499 to 959:0 node 993 handle 2 size 68:0
30319194: call  from 1859:1963 to 437:0 node 30318980 handle 8 size 96:0
30319195: reply from 437:447 to 1859:1963 node 0 handle -1 size 24:0
30319196: call  from 1859:1963 to 437:0 node 30318980 handle 8 size 84:0

The relevant code that prints the following is:
----------------------------------------------------------------------------
In binder.c:3614,

static void print_binder_transaction_log_entry(struct seq_file *m,
					struct binder_transaction_log_entry *e)
{
	seq_printf(m,
		   "%d: %s from %d:%d to %d:%d node %d handle %d size %d:%d\n",
		   e->debug_id, (e->call_type == 2) ? "reply" :
		   ((e->call_type == 1) ? "async" : "call "), e->from_proc,
		   e->from_thread, e->to_proc, e->to_thread, e->to_node,
		   e->target_handle, e->data_size, e->offsets_size);
}

Call hierarchy (can be skipped) :

binder.c :

BINDER_DEBUG_ENTRY() macro expands to binder_##name##_open() expands to 
        single_open(file, binder_##name##_show, inode->i_private) 
        and is called on proc, state, stats, transactions, transation_log 
        (we are interested in transaction_log)
(expands to)         binder_transaction_log_show  
--->                      print_binder_transaction_log_entry (where our logs are printed)


-----------------------------------------------------------------------------

The struct whose values are being read is 

struct binder_transaction_log_entry {
	int debug_id;
	int call_type;
	int from_proc;
	int from_thread;
	int target_handle;
	int to_proc;
	int to_thread;
	int to_node;
	int data_size;
	int offsets_size;
};

from_proc and to_proc is self explanatory and allows us to know the direction of control flow. 
We are interested in what call_type can tell us which would help us label the arrows in our sequence diagram.
For this, we need to know how it was set.

There are two types of binder_transaction_logs :
1. binder_transaction_log - written to in the beginning of binder_transaction(...) and ultimately writes to
/sys/kernel/debug/binder/transaction_log . This is interesting to us.

2. binder_transaction_log_failed - written to in binder_transaction(...) when the transaction fails. Writes
to /sys/kernel/debug/binder/failed_transaction_log. This is not what we will look at for the sequence diagrams.

Looking deeper at the first one :
From binder.c:
static void binder_transaction(struct binder_proc *proc,
			       struct binder_thread *thread,
			       struct binder_transaction_data *tr, int reply) {
             	    ...
                  struct binder_transaction_log_entry *e;
                  e = binder_transaction_log_add(&binder_transaction_log);
 interesting-->   e->call_type = reply ? 2 : !!(tr->flags & TF_ONE_WAY);
                	e->from_proc = proc->pid;
	                e->from_thread = thread->pid;
                 	e->target_handle = tr->target.handle;
	                e->data_size = tr->data_size;
	                e->offsets_size = tr->offsets_size;
                  ...
}

We need to know what tr->flags and TF_ONE_WAY correspond to:
TF_ONE_WAY is a global defined in binder.h 
(https://github.com/torvalds/linux/blob/master/include/uapi/linux/android/binder.h):
enum transaction_flags {
	TF_ONE_WAY	= 0x01,	/* this is a one-way call: async, no return */
	TF_ROOT_OBJECT	= 0x04,	/* contents are the component's root object */
	TF_STATUS_CODE	= 0x08,	/* contents are a 32-bit status code */
	TF_ACCEPT_FDS	= 0x10,	/* allow replies with file descriptors */
};

Hence , 
e->call_type is set to 2 if 'reply' is set during the invocation of binder_transaction.
e->call_type is set to 1 if tr->flags & TF_ONE_WAY evaluates to true. (one way async call)
e->call_type is set to 0 if tr->flags & TF_ONE_WAY evaluates to false. (BC_TRANSACTION)
